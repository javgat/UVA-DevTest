// Code generated by go-swagger; DO NOT EDIT.

package answer

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"uva-devtest/models"
)

// GetQuestionsFromAnswerHandlerFunc turns a function with the right signature into a get questions from answer handler
type GetQuestionsFromAnswerHandlerFunc func(GetQuestionsFromAnswerParams, *models.User) middleware.Responder

// Handle executing the request and returning a response
func (fn GetQuestionsFromAnswerHandlerFunc) Handle(params GetQuestionsFromAnswerParams, principal *models.User) middleware.Responder {
	return fn(params, principal)
}

// GetQuestionsFromAnswerHandler interface for that can handle valid get questions from answer params
type GetQuestionsFromAnswerHandler interface {
	Handle(GetQuestionsFromAnswerParams, *models.User) middleware.Responder
}

// NewGetQuestionsFromAnswer creates a new http.Handler for the get questions from answer operation
func NewGetQuestionsFromAnswer(ctx *middleware.Context, handler GetQuestionsFromAnswerHandler) *GetQuestionsFromAnswer {
	return &GetQuestionsFromAnswer{Context: ctx, Handler: handler}
}

/* GetQuestionsFromAnswer swagger:route GET /answers/{answerid}/questions answer getQuestionsFromAnswer

Returns all published questions in the test related to the answer. The DTOs will contain isRespondida

Returns all published questions in the test related to the answer. The DTOs will contain isRespondida

*/
type GetQuestionsFromAnswer struct {
	Context *middleware.Context
	Handler GetQuestionsFromAnswerHandler
}

func (o *GetQuestionsFromAnswer) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetQuestionsFromAnswerParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.User
	if uprinc != nil {
		principal = uprinc.(*models.User) // this is really a models.User, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
