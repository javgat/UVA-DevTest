// Code generated by go-swagger; DO NOT EDIT.

package user

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"uva-devtest/models"
)

// GetInvitedTestsByTeamsAndUserHandlerFunc turns a function with the right signature into a get invited tests by teams and user handler
type GetInvitedTestsByTeamsAndUserHandlerFunc func(GetInvitedTestsByTeamsAndUserParams, *models.User) middleware.Responder

// Handle executing the request and returning a response
func (fn GetInvitedTestsByTeamsAndUserHandlerFunc) Handle(params GetInvitedTestsByTeamsAndUserParams, principal *models.User) middleware.Responder {
	return fn(params, principal)
}

// GetInvitedTestsByTeamsAndUserHandler interface for that can handle valid get invited tests by teams and user params
type GetInvitedTestsByTeamsAndUserHandler interface {
	Handle(GetInvitedTestsByTeamsAndUserParams, *models.User) middleware.Responder
}

// NewGetInvitedTestsByTeamsAndUser creates a new http.Handler for the get invited tests by teams and user operation
func NewGetInvitedTestsByTeamsAndUser(ctx *middleware.Context, handler GetInvitedTestsByTeamsAndUserHandler) *GetInvitedTestsByTeamsAndUser {
	return &GetInvitedTestsByTeamsAndUser{Context: ctx, Handler: handler}
}

/* GetInvitedTestsByTeamsAndUser swagger:route GET /users/{username}/invitedTestsByTeamsAndUser user getInvitedTestsByTeamsAndUser

Returns all publishedTests where the user is invited as user or as team member

Returns all publishedTests where the user is invited as as user or as team member

*/
type GetInvitedTestsByTeamsAndUser struct {
	Context *middleware.Context
	Handler GetInvitedTestsByTeamsAndUserHandler
}

func (o *GetInvitedTestsByTeamsAndUser) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetInvitedTestsByTeamsAndUserParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.User
	if uprinc != nil {
		principal = uprinc.(*models.User) // this is really a models.User, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
