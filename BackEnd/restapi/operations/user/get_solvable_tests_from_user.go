// Code generated by go-swagger; DO NOT EDIT.

package user

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"uva-devtest/models"
)

// GetSolvableTestsFromUserHandlerFunc turns a function with the right signature into a get solvable tests from user handler
type GetSolvableTestsFromUserHandlerFunc func(GetSolvableTestsFromUserParams, *models.User) middleware.Responder

// Handle executing the request and returning a response
func (fn GetSolvableTestsFromUserHandlerFunc) Handle(params GetSolvableTestsFromUserParams, principal *models.User) middleware.Responder {
	return fn(params, principal)
}

// GetSolvableTestsFromUserHandler interface for that can handle valid get solvable tests from user params
type GetSolvableTestsFromUserHandler interface {
	Handle(GetSolvableTestsFromUserParams, *models.User) middleware.Responder
}

// NewGetSolvableTestsFromUser creates a new http.Handler for the get solvable tests from user operation
func NewGetSolvableTestsFromUser(ctx *middleware.Context, handler GetSolvableTestsFromUserHandler) *GetSolvableTestsFromUser {
	return &GetSolvableTestsFromUser{Context: ctx, Handler: handler}
}

/* GetSolvableTestsFromUser swagger:route GET /users/{username}/solvableTests user getSolvableTestsFromUser

Returns all publishedTests that the user can answer, including public ones and team ones.

Returns all publishedTests that the user can answer, including public ones and team ones.

*/
type GetSolvableTestsFromUser struct {
	Context *middleware.Context
	Handler GetSolvableTestsFromUserHandler
}

func (o *GetSolvableTestsFromUser) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetSolvableTestsFromUserParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.User
	if uprinc != nil {
		principal = uprinc.(*models.User) // this is really a models.User, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
